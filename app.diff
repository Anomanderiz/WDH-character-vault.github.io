--- a/app.js
+++ b/app.js
@@ -31,6 +31,165 @@
 function fmtSigned(n) {
   const x = Number(n ?? 0);
   return (x >= 0 ? `+${x}` : `${x}`);
 }
 
+// =======================
+// dnd5e derived maths (exports often omit computed fields)
+// =======================
+function abilityMod(score) {
+  const s = Number(score);
+  if (!Number.isFinite(s)) return 0;
+  return Math.floor((s - 10) / 2);
+}
+
+function totalLevel(actor) {
+  const sys = actor?.system || {};
+  const items = actor?.items || [];
+  const classes = items.filter(i => i?.type === "class");
+  const lvl = classes.reduce((a, c) => a + Number(c?.system?.levels ?? 0), 0);
+  return lvl || Number(sys?.details?.level ?? 0) || 0;
+}
+
+function proficiencyBonus(level) {
+  const l = Number(level);
+  if (!Number.isFinite(l) || l <= 0) return 0;
+  return 2 + Math.floor((l - 1) / 4);
+}
+
+function parseFlatBonus(v) {
+  if (v == null) return 0;
+  if (typeof v === "number") return Number.isFinite(v) ? v : 0;
+  const s = String(v).trim();
+  if (!s) return 0;
+  // Avoid trying to "understand" dice formulae.
+  if (/[dD]\d/.test(s)) return 0;
+  const nums = s.match(/[+-]?\d+/g);
+  if (!nums) return 0;
+  return nums.map(n => Number(n)).filter(Number.isFinite).reduce((a, b) => a + b, 0);
+}
+
+function profComponent(rank, prof) {
+  const r = Number(rank ?? 0);
+  if (!Number.isFinite(r) || r <= 0) return 0;
+  if (r === 0.5) return Math.floor(prof / 2);
+  if (r === 1) return prof;
+  if (r === 2) return 2 * prof;
+  return Math.floor(r * prof);
+}
+
+function dnd5eDerived(actor) {
+  const sys = actor?.system || {};
+  const level = totalLevel(actor);
+  const prof = proficiencyBonus(level);
+
+  const abilities = sys?.abilities || {};
+  const abilityMods = {
+    str: abilityMod(abilities?.str?.value),
+    dex: abilityMod(abilities?.dex?.value),
+    con: abilityMod(abilities?.con?.value),
+    int: abilityMod(abilities?.int?.value),
+    wis: abilityMod(abilities?.wis?.value),
+    cha: abilityMod(abilities?.cha?.value),
+  };
+
+  // Skills total = ability mod + prof component + bonuses
+  const skills = sys?.skills || {};
+  const skillTotals = {};
+  for (const [k, sk] of Object.entries(skills)) {
+    const ability = sk?.ability;
+    const base = ability && abilityMods[ability] != null ? abilityMods[ability] : 0;
+    const profPart = profComponent(sk?.value, prof);
+    const bonus =
+      parseFlatBonus(sk?.bonuses?.check) +
+      parseFlatBonus(sys?.bonuses?.abilities?.skill) +
+      parseFlatBonus(sys?.bonuses?.skills?.check);
+    skillTotals[k] = base + profPart + bonus;
+  }
+
+  // Passive Perception – if it isn't in the export, compute it.
+  const passivePrc =
+    10 +
+    (skillTotals?.prc ?? 0) +
+    parseFlatBonus(skills?.prc?.bonuses?.passive) +
+    parseFlatBonus(sys?.bonuses?.skills?.passive);
+
+  return { level, prof, abilityMods, skillTotals, passivePrc };
+}
+
+function computeAC(actor, derived) {
+  const sys = actor?.system || {};
+  const ac = sys?.attributes?.ac || {};
+
+  // If the export included a resolved value, use it.
+  if (Number.isFinite(ac?.value)) return Number(ac.value);
+  if (Number.isFinite(ac?.flat)) return Number(ac.flat);
+
+  const items = actor?.items || [];
+  const equipped = items.filter(i => i?.system?.equipped);
+
+  // Armour pieces (exclude shields)
+  const armours = equipped.filter(
+    i => i?.type === "equipment" &&
+      Number.isFinite(i?.system?.armor?.value) &&
+      (i?.system?.type?.value !== "shield")
+  );
+  // Shields
+  const shields = equipped.filter(
+    i => i?.type === "equipment" &&
+      Number.isFinite(i?.system?.armor?.value) &&
+      (i?.system?.type?.value === "shield")
+  );
+
+  const bestArmour = armours
+    .sort((a, b) => Number(b?.system?.armor?.value ?? 0) - Number(a?.system?.armor?.value ?? 0))[0];
+  const armourBase = bestArmour ? Number(bestArmour.system.armor.value) : 10;
+  const dexCap = bestArmour ? bestArmour?.system?.armor?.dex : null; // number or null
+  const dex = derived?.abilityMods?.dex ?? 0;
+  const dexUsed = (dexCap == null || dexCap === "") ? dex : Math.min(dex, Number(dexCap) || 0);
+
+  const shieldBonus = shields.reduce((a, s) => a + Number(s?.system?.armor?.value ?? 0), 0);
+  const flatBonus = parseFlatBonus(ac?.bonus);
+
+  // Matches your custom formula: @attributes.ac.armor + @abilities.dex.mod
+  // Where "ac.armor" is effectively (armourBase + shieldBonus), and dex is capped by armour.dex.
+  return armourBase + dexUsed + shieldBonus + flatBonus;
+}
+
+function spellPreparedLabel(spell) {
+  const s = spell?.system || {};
+  // dnd5e v4 stores this as 0/1/2
+  const p = s?.prepared;
+  if (p === 2) return "Always prepared";
+  if (p === 1) return "Prepared";
+  if (p === 0) return "Not prepared";
+
+  // Older/alt schema
+  const mode = s?.preparation?.mode;
+  if (mode === "prepared") return s?.preparation?.prepared ? "Prepared" : "Not prepared";
+  if (mode === "always") return "Always prepared";
+  return "";
+}
+
+const FILTERED_FEATURES = new Set([
+  "hide","search","attack","check cover","dash","disengage","grapple",
+  "knock out","magic","ready","ready spell","stabilise","study","underwater",
+  "dodge","fall","help","influence","mount","ready action","shove","squeeze","suffocation"
+]);
+
+function shouldHideFeature(item) {
+  return FILTERED_FEATURES.has(norm(item?.name));
+}
+
+function inventorySearchNode(gear) {
+  const wrap = document.createElement("div");
+  wrap.className = "flex flex-col gap-3";
+
+  const input = document.createElement("input");
+  input.type = "search";
+  input.placeholder = "Search inventory…";
+  input.className =
+    "w-full rounded-2xl bg-slate-950/40 border border-white/10 px-3 py-2 text-slate-100 " +
+    "placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-white/20";
+
+  const listWrap = document.createElement("div");
+
+  const render = () => {
+    const q = norm(input.value);
+    const filtered = !q ? gear : gear.filter(g => norm(g?.name).includes(q));
+    listWrap.innerHTML = "";
+    listWrap.appendChild(
+      filtered.length
+        ? listCards(filtered, (g) => {
+            const qty = g?.system?.quantity;
+            const eq = g?.system?.equipped ? "equipped" : "";
+            return [`qty ${qty ?? 1}`, eq].filter(Boolean).join(" • ");
+          })
+        : document.createTextNode("No matching items.")
+    );
+  };
+
+  input.addEventListener("input", render);
+  wrap.appendChild(input);
+  wrap.appendChild(listWrap);
+  render();
+  return wrap;
+}
+
@@ -41,22 +200,23 @@
 function dnd5eMeta(actor) {
   const sys = actor?.system || {};
-  const hp = sys?.attributes?.hp;
-  const ac = sys?.attributes?.ac;
-  const prof = sys?.attributes?.prof;
   const init = sys?.attributes?.init;
   const spell = sys?.attributes?.spellcasting;
 
   // class/level heuristics: sum class item levels
   const items = actor?.items || [];
   const classes = items.filter(i => i?.type === "class");
-  const level = classes.reduce((a, c) => a + Number(c?.system?.levels ?? 0), 0) || sys?.details?.level || "";
+  const level = totalLevel(actor) || "";
   const classNames = classes.map(c => c?.name).filter(Boolean).join(", ");
 
+  const derived = dnd5eDerived(actor);
+  const acValue = computeAC(actor, derived);
+  const hp = sys?.attributes?.hp;
+
   return {
     line1: [classNames || sys?.details?.class || "Character", level ? `Lv ${level}` : ""].filter(Boolean).join(" • "),
-    line2: [`AC ${ac?.value ?? "–"}`, `HP ${hp?.value ?? "–"}/${hp?.max ?? "–"}`, `PB ${fmtSigned(prof ?? 0)}`].join("  ·  "),
-    init: init?.mod ?? init?.total ?? init?.value,
+    line2: [`AC ${Number.isFinite(acValue) ? acValue : "–"}`, `HP ${hp?.value ?? "–"}/${hp?.max ?? "–"}`, `PB ${fmtSigned(derived.prof)}`].join("  ·  "),
+    init: init?.mod ?? init?.total ?? init?.value ?? derived?.abilityMods?.dex,
     spellcasting: spell
   };
 }
@@ -177,6 +337,8 @@
 function renderDnd5e(payload) {
   const actor = actorFromPayload(payload);
   const sys = actor?.system || {};
   const meta = dnd5eMeta(actor);
+  const derived = dnd5eDerived(actor);
+  const acValue = computeAC(actor, derived);
 
@@ -208,24 +370,24 @@
   const abilities = sys?.abilities || {};
   const abilityRows = [
-    ["STR", `${abilities?.str?.value ?? "–"} (${fmtSigned(abilities?.str?.mod ?? 0)})`],
+    ["STR", `${abilities?.str?.value ?? "–"} (${fmtSigned(derived.abilityMods.str)})`],
-    ["DEX", `${abilities?.dex?.value ?? "–"} (${fmtSigned(abilities?.dex?.mod ?? 0)})`],
+    ["DEX", `${abilities?.dex?.value ?? "–"} (${fmtSigned(derived.abilityMods.dex)})`],
-    ["CON", `${abilities?.con?.value ?? "–"} (${fmtSigned(abilities?.con?.mod ?? 0)})`],
+    ["CON", `${abilities?.con?.value ?? "–"} (${fmtSigned(derived.abilityMods.con)})`],
-    ["INT", `${abilities?.int?.value ?? "–"} (${fmtSigned(abilities?.int?.mod ?? 0)})`],
+    ["INT", `${abilities?.int?.value ?? "–"} (${fmtSigned(derived.abilityMods.int)})`],
-    ["WIS", `${abilities?.wis?.value ?? "–"} (${fmtSigned(abilities?.wis?.mod ?? 0)})`],
+    ["WIS", `${abilities?.wis?.value ?? "–"} (${fmtSigned(derived.abilityMods.wis)})`],
-    ["CHA", `${abilities?.cha?.value ?? "–"} (${fmtSigned(abilities?.cha?.mod ?? 0)})`],
+    ["CHA", `${abilities?.cha?.value ?? "–"} (${fmtSigned(derived.abilityMods.cha)})`],
   ];
@@ -218,12 +380,12 @@
   const combatRows = [
-    ["Armour Class", attr?.ac?.value ?? "–"],
+    ["Armour Class", Number.isFinite(acValue) ? acValue : "–"],
     ["Hit Points", `${attr?.hp?.value ?? "–"} / ${attr?.hp?.max ?? "–"}${attr?.hp?.temp ? ` (temp ${attr?.hp?.temp})` : ""}`],
-    ["Initiative", fmtSigned(attr?.init?.mod ?? attr?.init?.total ?? attr?.init ?? 0)],
-    ["Proficiency Bonus", fmtSigned(attr?.prof ?? 0)],
+    ["Initiative", fmtSigned(attr?.init?.mod ?? attr?.init?.total ?? attr?.init ?? derived.abilityMods.dex)],
+    ["Proficiency Bonus", fmtSigned(derived.prof)],
     ["Speed", `walk ${movement?.walk ?? "–"}${movement?.fly ? `, fly ${movement.fly}` : ""}${movement?.swim ? `, swim ${movement.swim}` : ""}`],
-    ["Passive Perception", sys?.skills?.prc?.passive ?? "–"],
+    ["Passive Perception", Number.isFinite(derived.passivePrc) ? derived.passivePrc : "–"],
   ];
@@ -238,7 +400,7 @@
-  const skillRows = Object.keys(skillLabels).map(k => [skillLabels[k], fmtSigned(skills?.[k]?.total ?? skills?.[k]?.mod ?? 0)]);
+  const skillRows = Object.keys(skillLabels).map(k => [skillLabels[k], fmtSigned(derived.skillTotals?.[k] ?? 0)]);
@@ -252,8 +414,8 @@
-      const prep = s?.system?.preparation?.mode;
+      const prep = spellPreparedLabel(s);
       return [lvl === 0 ? "Cantrip" : `Level ${lvl}`, school, prep].filter(Boolean).join(" • ");
@@ -262,12 +424,9 @@
-  root.appendChild(section("Features", feats.length ? listCards(feats) : document.createTextNode("No features exported.")));
-  root.appendChild(section("Inventory", gear.length ? listCards(gear, (g) => {
-    const qty = g?.system?.quantity;
-    const eq = g?.system?.equipped ? "equipped" : "";
-    return [`qty ${qty ?? 1}`, eq].filter(Boolean).join(" • ");
-  }) : document.createTextNode("No inventory exported.")));
+  const cleanedFeats = feats.filter(f => !shouldHideFeature(f));
+  root.appendChild(section("Features", cleanedFeats.length ? listCards(cleanedFeats) : document.createTextNode("No features exported.")));
+  root.appendChild(section("Inventory", gear.length ? inventorySearchNode(gear) : document.createTextNode("No inventory exported.")));
